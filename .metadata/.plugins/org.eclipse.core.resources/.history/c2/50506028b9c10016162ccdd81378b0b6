package treeRefBased;

public class BinarySearchTree 
						<T extends KeyedItem<KT>, KT extends Comparable<? super KT>>
							extends BinaryTreeRefBased {
	
	public BinarySearchTree(){
		
	}
	
	public BinarySearchTree(T rootItem){
		super(rootItem);
	}

	@Override
	public void setRootItem(Object item) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}
	
	public void insert(T item){
		root = insertItem(root, item);
	}

	public T retrieve(KT searchKey){
		return retrieveItem(root, searchKey);
	}
	public void delete(KT searchKey){
		root = deleteItem(root, searchKey);
	}

	public void delete(T item){
		root = deleteItem(root, item.getKey());
	}
	
	
	protected T retrieveItem(TreeNode<T> root, KT searchKey) {
		// TODO Auto-generated method stub
		if(root==null)
		{
			return null;
		}

		while(root!=null){
		if (searchKey.compareTo(root.item.getKey())<0)
		{
			return (retrieveItem(root.leftChild,searchKey));
		}
		else if(searchKey.compareTo(root.item.getKey())>0)
		{
			return (retrieveItem(root.rightChild,searchKey));
		}
		
		}
		return root;
		
	}

	protected TreeNode<T> insertItem(TreeNode<T> tNode, T item) {
		TreeNode<T> newSubTree;
		if(tNode == null){//insert after leaf
			tNode = new TreeNode<T>(item, null, null);
			return tNode;
		}
		T nodeItem = tNode.item;
		if(item.getKey().compareTo(nodeItem.getKey())  < 0){//go left
			newSubTree = insertItem(tNode.leftChild, item); //recursive call
			tNode.leftChild = newSubTree;
			return tNode;
		}
		else{//go right
			newSubTree = insertItem(tNode.rightChild, item);
			tNode.rightChild = newSubTree;
			return tNode;
		}
	}
	protected TreeNode<T> deleteItem(TreeNode<T> tNode, KT searchKey){
		TreeNode<T> newSubTree;
		if(tNode == null){
			throw new TreeException("ITEM NOT FOUND");
		}
		else{
			T nodeItem = tNode.item;
			if(searchKey.compareTo(nodeItem.getKey())  == 0){
				tNode = deleteNode(tNode); // call deleteNode method
			}
			else if(searchKey.compareTo(nodeItem.getKey())  < 0){
				newSubTree = deleteItem(tNode.leftChild, searchKey); //recursive call
				tNode.leftChild = newSubTree;
			}
			else{
				newSubTree = deleteItem(tNode.rightChild, searchKey); //recursive call
				tNode.rightChild = newSubTree;
	
			}
			
		}
		return tNode;
		
		
	}

	private TreeNode<T> deleteNode(TreeNode<T> tNode) {
		// TODO Auto-generated method stub
		return null;
	}
	

}
